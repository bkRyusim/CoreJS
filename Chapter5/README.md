# Chapter.5 클로저

1. `inner`가 `outer`의 `a`를 참조함. 이 정보가 `Closure`환경에 기록되며 `outer`가 사라져도 `inner`는 `a`를 참조할 수 있음.
2. `outer`의 `a`를 참조하고 1을 더해 출력.
3. `inner`를 리턴하여 `outer`없이 `inner`함수를 호출함. `a`가 `Closure` 환경에 남아 계속 1을 가리키고 있고, `inner`에서 그대로 사용할 수 있다.
4. 바로 실행하여 사라지는 함수지만 콜백 함수로 내부에서 정의한 함수를 `setTimeout()`이나 `eventListener()`에게 제공한 경우, 클로저에 context가 남게 된다.
5. ㅁㅇㄹ
6. `fruits`를 순회하며 `addEventListener()`로 콜백 함수를 생성하여 넘길 때, 콜백 함수 내부에서 외부의 `fruit`을 사용하여 클로저에 남게 되고, 이후 이벤트가
   발생하면 `Closure`에 남은 `fruit`을 참조하게 된다.
7. `addEventListener()`는 첫번째 인자에 `event` 객체를 주입함. 그래서 원하는 동작이 수행되지 않는다.
8. `bind()`를 활용하여 `fruit`을 인자로 넘겨준 새로운 함수를 생성함. 다만 이 경우 `this`가 바뀌기 때문에 좋은 코드가 아님.
9. `alertFruitBuilder()`를 만들어 `alertFruit()`함수를 생성하는 빌더를 구현함. 리턴되는 내부 함수는 빌더에 인자로 넘어온 fruit을 참조하고, 클로저 환경에 기록되어 이후 함수
   호출에서도 참조할 수 있음.
10. property들이 보호받지 못한 상태.
11. object 내에 `fuel`, `power`, `moved` 프로퍼티는 없지만, 클로저를 활용해 참조할 수 있음. 함수 앞에 `get`을 붙이면 `getter`를 뜻함.
12. `freeze()` 이용해 객체 수정 불가능.
13. 부분 적용 함수 : 미리 인자를 몇개 주입해 두고 남은 인자를 나중에 사용.
14. partial function을 생성하는 함수. 첫번째 인자로 함수를 받고 그 다음부터 미리 주입할 인자를 받음. 이후 원래 인자와 이후 들어오는 인자를 concat해서 함수를 실행시키는 함수를 리턴함.
15. `object`의 `defineProperty()`를 활용해 `global`의 `_`를 다시 정의함. 이후 partial function에서 원래 인자에 `_`가 들어있던 자리를 새로운 인자들이 채워서 실행됨.
16. 이벤트가 발생하면 timeout을 설정하고, 연속된 이벤트 중 마지막 이벤트만 이벤트로 인식하는 debounce를 구현함.
17. 커링함수를 구현하여 10과 대소비교 하는 함수 작성
18. 5개 숫자 중 가장 큰 수를 출력하는 커링 함수. `func => a => b => c => d => e => func(a, b, c, d, e);`로 한 줄로 쓸 수도 있다.(ES6)